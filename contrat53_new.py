"""
Module de gestion des contrats pour la SELARL Anesth√©sistes Mathilde.
Ce module g√®re la cr√©ation et la gestion des contrats MAR et IADE.
"""

import pandas as pd
import tkinter as tk
from tkinter import StringVar, Entry, OptionMenu, messagebox
from tkcalendar import Calendar
from datetime import datetime
import os
import subprocess
import json
import threading
import time
import pyautogui
from config import file_paths

def convert_date_format(date_str, from_format="yyyy-mm-dd", to_format="dd-mm-yyyy"):
    """Convertit une date d'un format √† un autre."""
    if not date_str:
        return date_str
        
    try:
        if from_format == "yyyy-mm-dd" and to_format == "dd-mm-yyyy":
            year, month, day = date_str.split('-')
            return f"{day}-{month}-{year}"
        elif from_format == "dd-mm-yyyy" and to_format == "yyyy-mm-dd":
            day, month, year = date_str.split('-')
            return f"{year}-{month}-{day}"
        return date_str
    except:
        return date_str  # En cas d'erreur, renvoyer la date d'origine

def ensure_correct_date_format(date_str, required_format="yyyy-mm-dd"):
    """
    S'assure que la date est dans le format requis pour traitement par la base de donn√©es.
    Convertit une date du format DD-MM-YYYY vers YYYY-MM-DD si n√©cessaire.
    """
    if not date_str:
        return date_str
        
    # Si la date est d√©j√† au format YYYY-MM-DD
    if len(date_str.split('-')) == 3 and date_str.split('-')[0].isdigit() and len(date_str.split('-')[0]) == 4:
        return date_str
        
    # Convertir de DD-MM-YYYY vers YYYY-MM-DD
    try:
        day, month, year = date_str.split('-')
        if len(year) == 4 and len(day) <= 2 and len(month) <= 2:  # V√©rifier si c'est bien DD-MM-YYYY
            return f"{year}-{month}-{day}"
    except:
        pass  # Si la s√©paration √©choue, on continue
        
    # Sinon, renvoyer la cha√Æne d'origine
    return date_str

def save_to_new_excel(dataframe, new_excel_path, sheet_name="CONTRAT"):
    """Cr√©e un nouveau fichier Excel avec la feuille sp√©cifi√©e sans bo√Ætes de dialogue."""
    try:
        with pd.ExcelWriter(new_excel_path, engine="openpyxl") as writer:
            dataframe.to_excel(writer, sheet_name=sheet_name, index=False)
        return True
    except Exception as e:
        print(f"Erreur lors de la sauvegarde du fichier Excel : {e}")
        return False

def activate_word():
    """
    Active Microsoft Word en utilisant AppleScript avant de chercher les boutons.
    """
    applescript = """
    tell application "Microsoft Word"
        activate
    end tell
    """
    try:
        subprocess.run(["osascript", "-e", applescript], check=True)
        print("Microsoft Word activ√©.")
    except Exception as e:
        print(f"Erreur lors de l'activation de Microsoft Word : {e}")

def quit_word():
    """
    Ferme Microsoft Word √† la fin du script.
    """
    applescript = """
    tell application "Microsoft Word"
        quit saving no
    end tell
    """
    try:
        subprocess.run(["osascript", "-e", applescript], check=True)
        print("Microsoft Word ferm√©.")
    except Exception as e:
        print(f"Erreur lors de la fermeture de Microsoft Word : {e}")

def handle_popups():
    """
    G√®re les popups de Word avec des clics automatiques bas√©s sur des coordonn√©es fixes.
    """
    try:
        print("Attente des fen√™tres popups...")
        time.sleep(1)  # Attendre que les popups apparaissent

        # Coordonn√©es des boutons (√† ajuster si besoin)
        x_oui, y_oui = 936, 455  # Coordonn√©es du bouton "Oui"
        x_ok, y_ok = 946, 420    # Coordonn√©es du bouton "OK"

        # Clic sur "Oui"
        print(f"Clic sur 'Oui' aux coordonn√©es : ({x_oui}, {y_oui})")
        pyautogui.moveTo(x_oui, y_oui, duration=0.2)
        pyautogui.click()

        # Pause avant de g√©rer "OK"
        time.sleep(1)

        # Clic sur "OK"
        print(f"Clic sur 'OK' aux coordonn√©es : ({x_ok}, {y_ok})")
        pyautogui.moveTo(x_ok, y_ok, duration=0.2)
        pyautogui.click()

        print("Les boutons ont √©t√© cliqu√©s avec succ√®s.")
    except Exception as e:
        print(f"Erreur lors de la gestion des popups : {e}")

def perform_mail_merge(word_file, replaced_name, replacing_name, start_date, pdf_folder, contract_type="MAR"):
    """
    Effectue un publipostage pour g√©n√©rer un contrat PDF.
    
    Args:
        word_file: Chemin du mod√®le Word
        replaced_name: Nom du m√©decin remplac√© (pour MAR)
        replacing_name: Nom du rempla√ßant
        start_date: Date de d√©but du contrat
        pdf_folder: Dossier o√π enregistrer le PDF
        contract_type: Type de contrat ("MAR" ou "IADE")
        
    Returns:
        Le chemin du fichier PDF g√©n√©r√© ou None en cas d'erreur
    """
    print(f"üìÑ Dossier PDF : {pdf_folder}")
    print(f"üìÑ Mod√®le Word : {word_file}")
    print(f"üë®‚Äç‚öïÔ∏è Remplac√© : {replaced_name}")
    print(f"üë®‚Äç‚öïÔ∏è Rempla√ßant : {replacing_name}")
    print(f"üìÖ Date d√©but : {start_date}")
    print(f"üìÑ Type contrat : {contract_type}")

    # Assurer que le dossier cible existe
    if not os.path.exists(pdf_folder):
        os.makedirs(pdf_folder)

    # Formatage de la date pour le nom du fichier
    formatted_date = datetime.strptime(start_date, "%Y-%m-%d").strftime("%Y%m%d")

    # G√©n√©ration du nom de fichier PDF
    if contract_type == "MAR":
        if not replaced_name or not replacing_name:
            print("‚ùå Erreur : Noms des m√©decins incorrects.")
            return None
        pdf_filename = f"{formatted_date}_Contrat_{replacing_name}_{replaced_name}.pdf"
    elif contract_type == "IADE":
        if not replacing_name:
            print("‚ùå Erreur : Nom du rempla√ßant manquant.")
            return None
        pdf_filename = f"{formatted_date}_CDD_{replacing_name.strip()}.pdf"
    else:
        print(f"‚ùå Erreur : Type de contrat inconnu {contract_type}")
        return None

    output_pdf_path = os.path.join(pdf_folder, pdf_filename)
    print(f"üìÑ Chemin pr√©vu pour le PDF : {output_pdf_path}")

    # Script AppleScript mis √† jour
    applescript = f"""
    tell application "Microsoft Word"
        activate
        open POSIX file "{word_file}"
        delay 3 -- Attendre que Word charge le document

        -- Sauvegarde en PDF
        set output_pdf_path to POSIX file "{output_pdf_path}"
        save as active document file name output_pdf_path file format format PDF

        -- Fermer le document sans enregistrer
        close active document saving no
    end tell
    """

    try:
        # Lancer Word en arri√®re-plan pour √©viter que Python ne soit bloqu√©
        word_process = subprocess.Popen(["osascript", "-e", applescript])

        # Attendre un peu que Word ouvre sa fen√™tre
        time.sleep(2)

        # Lancer handle_popups() en parall√®le pour cliquer sur "Oui" et "OK"
        popup_thread = threading.Thread(target=handle_popups)
        popup_thread.start()

        # Attendre que Word termine (optionnel, si besoin)
        word_process.wait()

        print(f"‚úÖ PDF g√©n√©r√© : {output_pdf_path}")

        if os.path.exists(output_pdf_path):
            return output_pdf_path  
        else:
            print("‚ùå Erreur : Fichier PDF non trouv√© apr√®s g√©n√©ration.")
            return None  

    except Exception as e:
        print(f"‚ùå Erreur lors du publipostage : {e}")
        return None

def show_post_contract_actions(container, pdf_path, replaced_name, replacing_name, 
                            replaced_email, replacing_email, start_date, end_date, contract_type):
    """
    Affiche les options post-cr√©ation de contrat dans le conteneur sp√©cifi√©.
    """
    # Nettoyer le conteneur d'abord
    for widget in container.winfo_children():
        widget.destroy()
    
    # Titre
    tk.Label(container, text="Actions disponibles", font=("Arial", 14, "bold"), 
           bg="#4a90e2", fg="white").pack(fill="x", pady=10)
    
    # Description
    tk.Label(container, text=f"Contrat g√©n√©r√© pour:\n{replacing_name}\nrempla√ßant {replaced_name}\n{start_date} - {end_date}", 
           font=("Arial", 10), justify=tk.LEFT, bg="#f5f5f5").pack(pady=10, anchor="w")
    
    # Bouton pour ouvrir le PDF
    def open_pdf():
        """Ouvre le contrat avec PDF Expert."""
        subprocess.run(["open", "-a", "PDF Expert", pdf_path])
    
    tk.Button(container, text="üìÑ Ouvrir avec PDF Expert", command=open_pdf, 
            width=30).pack(pady=5)
    
    # Bouton pour envoyer √† DocuSign
    tk.Button(container, text="üì© Envoyer en DocuSign", 
            command=lambda: send_to_docusign(pdf_path, contract_type, start_date, end_date, 
                                            replacing_name, replacing_email, 
                                            replaced_name, replaced_email), 
            width=30).pack(pady=5)
    
    # Bouton pour effectuer le r√®glement (d√©sactiv√©)
    tk.Button(container, text="üí∞ Effectuer le r√®glement (√† venir)", 
            state="disabled", width=30).pack(pady=5)

def send_to_docusign(pdf_path, contract_type, start_date, end_date, replacing_name, replacing_email, replaced_name=None, replaced_email=None):
    """
    Simule l'envoi du fichier PDF g√©n√©r√© √† DocuSign.
    """
    print(f"üì§ Simulation d'envoi √† DocuSign...")
    print(f"   üìÑ Fichier : {pdf_path}")
    print(f"   üè∑Ô∏è Type de contrat : {contract_type}")
    print(f"   üìÜ P√©riode : {start_date} - {end_date}")
    print(f"   üë®‚Äç‚öïÔ∏è Rempla√ßant : {replacing_name} ({replacing_email})")
    if replaced_name:
        print(f"   üë®‚Äç‚öïÔ∏è Remplac√© : {replaced_name} ({replaced_email})")
    
    messagebox.showinfo("DocuSign", "Le contrat a √©t√© envoy√© √† DocuSign avec succ√®s (simulation).")

def create_contract_interface_mar(parent_frame):
    """
    Cr√©e l'interface de cr√©ation de contrat MAR dans le frame parent fourni.
    
    Args:
        parent_frame: Le frame parent dans lequel cr√©er l'interface
    """
    try:
        # Chargement des donn√©es
        mars_selarl = pd.read_excel(file_paths["excel_mar"], sheet_name="MARS SELARL")
        mars_rempla = pd.read_excel(file_paths["excel_mar"], sheet_name="MARS Rempla√ßants")
        
        # Concat√©nation PRENOM + NOM en une seule colonne normalis√©e
        mars_selarl["FULL_NAME"] = mars_selarl["PRENOM"].fillna("").str.strip() + " " + mars_selarl["NOM"].fillna("").str.strip()
        mars_rempla["FULL_NAME"] = mars_rempla["PRENOMR"].fillna("").str.strip() + " " + mars_rempla["NOMR"].fillna("").str.strip()
        
        # Conteneur principal - utilisation d'un PanedWindow pour diviser l'espace
        main_container = tk.PanedWindow(parent_frame, orient=tk.HORIZONTAL)
        main_container.pack(fill="both", expand=True)
        
        # Cadre gauche pour le formulaire
        form_container = tk.Frame(main_container, bg="#f0f4f7", padx=20, pady=20)
        main_container.add(form_container, width=420)  # Largeur fixe pour le formulaire
        
        # Cadre droit pour les actions post-contrat (initialement vide)
        actions_container = tk.Frame(main_container, bg="#f5f5f5", padx=20, pady=20)
        main_container.add(actions_container, width=400)  # Largeur pour les actions
        
        # Titre du formulaire
        tk.Label(form_container, text="Nouveau contrat remplacement MAR", 
                font=("Arial", 14, "bold"), bg="#4a90e2", fg="white").pack(fill="x", pady=10)
        
        def select_dates():
            """Ouvre un calendrier pour s√©lectionner les dates de d√©but et de fin."""
            selected_dates = []

            def on_date_select():
                """Capture la date s√©lectionn√©e et met √† jour les variables."""
                selected_date = calendar.get_date()  # Format YYYY-MM-DD
                selected_dates.append(selected_date)
                
                if len(selected_dates) == 1:
                    # Mise √† jour de la variable uniquement (pas directement le widget)
                    start_date_var.set(selected_date)
                    message_var.set("S√©lectionnez la date de fin.")
                elif len(selected_dates) == 2:
                    # Trier les dates si n√©cessaire
                    start, end = sorted(selected_dates)
                    start_date_var.set(start)
                    end_date_var.set(end)
                    date_picker.destroy()

            def close_calendar():
                """Ferme le calendrier en ne retenant qu'une seule date si n√©cessaire."""
                if len(selected_dates) == 1:  # Si une seule date est s√©lectionn√©e
                    # Une seule date = m√™me d√©but et fin
                    start_date_var.set(selected_dates[0])
                    end_date_var.set(selected_dates[0])
                date_picker.destroy()

            # Cr√©e la fen√™tre de calendrier
            date_picker = tk.Toplevel(parent_frame.winfo_toplevel())
            date_picker.title("S√©lectionner les dates")
            date_picker.geometry("400x400")  # Fen√™tre plus grande
            date_picker.configure(bg="#f0f4f7")  # Fond assorti

            message_var = tk.StringVar()
            message_var.set("S√©lectionnez la date de d√©but.")
            
            # Titre principal stylis√©
            tk.Label(date_picker, 
                    text="S√©lection des dates", 
                    font=("Arial", 14, "bold"),
                    bg="#4a90e2", 
                    fg="white",
                    padx=10,
                    pady=5).pack(fill="x", pady=(0, 10))
                    
            # Message d'instruction
            instruction_label = tk.Label(date_picker, 
                                    textvariable=message_var, 
                                    font=("Arial", 11),
                                    bg="#f0f4f7",
                                    pady=5)
            instruction_label.pack(pady=5)

            # Calendrier am√©lior√©
            calendar = Calendar(
                date_picker,
                date_pattern="dd-mm-yyyy",  # Format jj-mm-aaaa
                background="#f0f4f7",       # Fond assorti
                foreground="#333333",       # Texte fonc√©
                selectbackground="#4a90e2", # Bleu pour s√©lection
                selectforeground="white",   # Texte blanc sur s√©lection
                normalbackground="white",   # Fond blanc jours normaux
                weekendbackground="#f5f5f5",# Gris clair weekends
                weekendforeground="#e74c3c",# Rouge pour weekends
                othermonthforeground="#aaaaaa", # Gris pour jours autres mois
                font=("Arial", 10),        # Police lisible
                bordercolor="#4a90e2",     # Bordure bleue
                headersbackground="#4a90e2", # En-t√™te bleu
                headersforeground="white",   # Texte blanc pour en-t√™te
            )
            calendar.pack(pady=10, padx=20, fill="both", expand=True)

            # Cadre pour les boutons avec style
            button_frame = tk.Frame(date_picker, bg="#f0f4f7")
            button_frame.pack(pady=10, fill="x")

            # Boutons stylis√©s
            select_button = tk.Button(
                button_frame, 
                text="Valider", 
                command=on_date_select,
                bg="#4a90e2", 
                fg="white",
                font=("Arial", 10, "bold"),
                width=10,
                padx=5,
                pady=3,
                relief="flat",
                cursor="hand2"
            )
            select_button.pack(side="left", padx=20)

            close_button = tk.Button(
                button_frame, 
                text="Fermer", 
                command=close_calendar,
                bg="#f44336", 
                fg="white",
                font=("Arial", 10, "bold"),
                width=10,
                padx=5,
                pady=3,
                relief="flat",
                cursor="hand2"
            )
            close_button.pack(side="right", padx=20)

            # Centrer la fen√™tre
            date_picker.update_idletasks()
            width = date_picker.winfo_width()
            height = date_picker.winfo_height()
            x = (date_picker.winfo_screenwidth() // 2) - (width // 2)
            y = (date_picker.winfo_screenheight() // 2) - (height // 2)
            date_picker.geometry(f'{width}x{height}+{x}+{y}')

            # D√©finir cette fen√™tre comme modale
            date_picker.transient(parent_frame.winfo_toplevel())
            date_picker.grab_set()
            date_picker.focus_set()
        
        def save_contract():
            """Sauvegarde les informations du contrat et g√©n√®re le PDF."""
            print("file_paths keys:", file_paths.keys())
            
            replaced_name = replaced_var.get().strip()
            replacing_name = replacing_var.get().strip()
            start_date = ensure_correct_date_format(start_date_var.get())
            end_date = ensure_correct_date_format(end_date_var.get())
            sign_date = ensure_correct_date_format(sign_date_var.get())
            daily_fee = daily_fee_var.get()
            
            # V√©rification insensible √† la casse et aux espaces
            replaced_matches = mars_selarl[mars_selarl["FULL_NAME"].str.strip().str.upper() == replaced_name.strip().upper()]
            if replaced_matches.empty:
                print(f"‚ùå Erreur : M√©decin remplac√© '{replaced_name}' introuvable dans la base.")
                print("üìã Liste des noms disponibles :", mars_selarl["FULL_NAME"].tolist())
                return
            replaced_data = replaced_matches.iloc[0]

            replacing_matches = mars_rempla[mars_rempla["FULL_NAME"].str.strip().str.upper() == replacing_name.strip().upper()]
            if replacing_matches.empty:
                print(f"‚ùå Erreur : M√©decin rempla√ßant '{replacing_name}' introuvable dans la base.")
                print("üìã Liste des noms disponibles :", mars_rempla["FULL_NAME"].tolist())
                return
            replacing_data = replacing_matches.iloc[0]

            print(f"üõ†Ô∏è DEBUG : Donn√©es du remplac√© : {replaced_data.to_dict()}")
            print(f"üõ†Ô∏è DEBUG : Donn√©es du rempla√ßant : {replacing_data.to_dict()}")

            # V√©rification des dates
            if not start_date or not end_date:
                print("‚ùå Erreur : Les dates ne sont pas d√©finies correctement.")
                return

            # R√©cup√©ration et nettoyage des emails
            replaced_email = replaced_data.get("EMAIL", "")
            if pd.isna(replaced_email) or not replaced_email:
                replaced_email = "email_inconnu@exemple.com"
            elif isinstance(replaced_email, str):
                replaced_email = replaced_email.strip()
                
            replacing_email = replacing_data.get("EMAILR", "")
            if pd.isna(replacing_email) or not replacing_email:
                replacing_email = "email_inconnu@exemple.com"
            elif isinstance(replacing_email, str):
                replacing_email = replacing_email.strip()

            # Cr√©ation d'une ligne pour la feuille CONTRAT
            new_row = [
                replaced_data["NOM"],
                replaced_data["PRENOM"],
                "N/A" if pd.isna(replaced_data["N ORDRE"]) else str(replaced_data["N ORDRE"]),
                replaced_email,
                replacing_data["NOMR"],
                replacing_data["PRENOMR"],
                "N/A" if pd.isna(replacing_data["N ORDRER"]) else str(replacing_data["N ORDRER"]),
                replacing_email,
                "N/A" if pd.isna(replacing_data["AdresseR"]) else str(replacing_data["AdresseR"]),
                "N/A" if pd.isna(replacing_data["URSSAF"]) else str(replacing_data["URSSAF"]),
                start_date,
                end_date,
                sign_date,
                int(daily_fee)
            ]

            # Cr√©ation d'un DataFrame avec la structure de la feuille CONTRAT
            contrat_columns = [
                "NOM", "PRENOM", "N ORDRE", "EMAIL",
                "NOMR", "PRENOMR", "N ORDRER", "EMAILR",
                "AdresseR", "URSSAF", "DATEDEBUT", "DATEFIN", "DATESIGN", "forfait"
            ]
            contrat = pd.DataFrame([new_row], columns=contrat_columns)

            # Pr√©paration pour le publipostage
            word_file = file_paths["word_mar"]
            base_dir = os.path.dirname(word_file)
            excel_path = os.path.join(base_dir, "contrat_mars_selarl.xlsx")
            
            # Sauvegarde du fichier Excel temporaire
            save_to_new_excel(contrat, excel_path)

            # G√©n√©ration du contrat PDF
            pdf_path = perform_mail_merge(
                file_paths["word_mar"],
                replaced_name,
                replacing_name,
                start_date,
                os.path.expanduser(file_paths["pdf_mar"]),
                contract_type="MAR"
            )

            if not pdf_path or not os.path.exists(pdf_path):
                print(f"‚ùå Erreur : Le fichier PDF n'a pas pu √™tre g√©n√©r√©.")
                return

            print(f"‚úÖ Contrat g√©n√©r√© : {pdf_path}")

            # D√©sactivation des widgets du formulaire
            for widget in form_frame.winfo_children():
                if isinstance(widget, (tk.Entry, tk.Button, tk.OptionMenu)):
                    widget.configure(state="disabled")
            
            # Vider le conteneur d'actions
            for widget in actions_container.winfo_children():
                widget.destroy()
            
            # Cr√©ation du conteneur pour les actions post-contrat
            show_post_contract_actions(
                actions_container, 
                pdf_path, 
                replaced_name, 
                replacing_name, 
                replaced_email, 
                replacing_email, 
                start_date, 
                end_date, 
                "MAR"
            )
        
        # Formulaire principal
        form_frame = tk.Frame(form_container, bg="#f0f4f7")
        form_frame.pack(pady=10, fill="x")
        
        # M√©decin remplac√©
        tk.Label(form_frame, text="M√©decin remplac√© :", bg="#f0f4f7").grid(row=0, column=0, sticky="w", pady=5)
        replaced_var = StringVar()
        tk.OptionMenu(form_frame, replaced_var, *mars_selarl["FULL_NAME"].tolist()).grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        # M√©decin rempla√ßant
        tk.Label(form_frame, text="M√©decin rempla√ßant :", bg="#f0f4f7").grid(row=1, column=0, sticky="w", pady=5)
        replacing_var = StringVar()
        tk.OptionMenu(form_frame, replacing_var, *mars_rempla["FULL_NAME"].tolist()).grid(row=1, column=1, sticky="w", padx=5, pady=5)
        
        # Bouton pour s√©lectionner les dates
        tk.Label(form_frame, text="Dates de d√©but et de fin :", bg="#f0f4f7").grid(row=2, column=0, sticky="w", pady=5)
        tk.Button(form_frame, text="üìÖ S√©lectionner les dates", command=select_dates).grid(row=2, column=1, sticky="w", padx=5, pady=5)
        
        start_date_var = StringVar()
        end_date_var = StringVar()
        
        # Champ pour afficher la date de d√©but
        tk.Label(form_frame, text="Date de d√©but :", bg="#f0f4f7").grid(row=3, column=0, sticky="w", pady=5)
        Entry(form_frame, textvariable=start_date_var, state="readonly").grid(row=3, column=1, sticky="w", padx=5, pady=5)
        
        # Champ pour afficher la date de fin
        tk.Label(form_frame, text="Date de fin :", bg="#f0f4f7").grid(row=4, column=0, sticky="w", pady=5)
        Entry(form_frame, textvariable=end_date_var, state="readonly").grid(row=4, column=1, sticky="w", padx=5, pady=5)
        
        # Date de signature
        tk.Label(form_frame, text="Date de signature :", bg="#f0f4f7").grid(row=5, column=0, sticky="w", pady=5)
        sign_date_var = StringVar(value=datetime.today().strftime("%Y-%m-%d"))
        Entry(form_frame, textvariable=sign_date_var).grid(row=5, column=1, sticky="w", padx=5, pady=5)
        
        # Forfait journalier
        tk.Label(form_frame, text="Forfait journalier (‚Ç¨) :", bg="#f0f4f7").grid(row=6, column=0, sticky="w", pady=5)
        daily_fee_var = StringVar(value="1000")
        Entry(form_frame, textvariable=daily_fee_var).grid(row=6, column=1, sticky="w", padx=5, pady=5)
        
        # Bouton de cr√©ation
        tk.Button(form_frame, text="Cr√©er le contrat", command=save_contract, 
               font=("Arial", 12, "bold"), bg="#007ACC", fg="black").grid(row=7, column=0, pady=10, padx=5, sticky="w")
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        tk.Label(parent_frame, text=f"Erreur lors de la cr√©ation de l'interface : {str(e)}", 
                 font=("Arial", 12), fg="red").pack(pady=20)

def create_contract_interface_iade(parent_frame):
    """
    Cr√©e l'interface de cr√©ation de contrat IADE dans le frame parent fourni.
    
    Args:
        parent_frame: Le frame parent dans lequel cr√©er l'interface
    """
    try:
        # Chargement des donn√©es
        iade_data = pd.read_excel(file_paths["excel_iade"], sheet_name="Coordonn√©es IADEs")
        
        # Conteneur principal - utilisation d'un PanedWindow pour diviser l'espace
        main_container = tk.PanedWindow(parent_frame, orient=tk.HORIZONTAL)
        main_container.pack(fill="both", expand=True)
        
        # Cadre gauche pour le formulaire
        form_container = tk.Frame(main_container, bg="#f0f4f7", padx=20, pady=20)
        main_container.add(form_container, width=420)  # Largeur fixe pour le formulaire
        
        # Cadre droit pour les actions post-contrat (initialement vide)
        actions_container = tk.Frame(main_container, bg="#f5f5f5", padx=20, pady=20)
        main_container.add(actions_container, width=400)  # Largeur pour les actions
        
        # Titre du formulaire
        tk.Label(form_container, text="ü©∫ Nouveau contrat IADE", 
                font=("Arial", 14, "bold"), bg="#4a90e2", fg="white").pack(fill="x", pady=10)
        
        # Formulaire principal
        form_frame = tk.Frame(form_container, bg="#f0f4f7")
        form_frame.pack(pady=10, fill="x")
        
        # IADE rempla√ßant
        tk.Label(form_frame, text="IADE rempla√ßant :", bg="#f0f4f7").grid(row=0, column=0, sticky="w", pady=5)
        replacing_var = StringVar()
        tk.OptionMenu(form_frame, replacing_var, *iade_data["NOMR"].tolist()).grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        # Fonction pour s√©lectionner les dates
        def select_dates():
            """Ouvre un calendrier pour s√©lectionner les dates de d√©but et de fin."""
            selected_dates = []

            def update_message():
                """Mise √† jour du message selon le nombre de dates s√©lectionn√©es."""
                if len(selected_dates) == 0:
                    message_var.set("S√©lectionnez la date de d√©but.")
                elif len(selected_dates) == 1:
                    message_var.set("S√©lectionnez la date de fin.")

            def on_date_select():
                """Capture la date s√©lectionn√©e."""
                selected_date = calendar.get_date()  # Format YYYY-MM-DD
                
                # Convertir au format DD-MM-YYYY pour l'affichage
                display_date = convert_date_format(selected_date, "yyyy-mm-dd", "dd-mm-yyyy")
                
                selected_dates.append(selected_date)
                update_message()

                if len(selected_dates) == 2:  # Deux dates s√©lectionn√©es
                    # Trier les dates si n√©cessaire
                    start_date, end_date = sorted(selected_dates)
                    
                    # Stocker les dates originales (YYYY-MM-DD) dans les variables pour traitement
                    start_date_var.set(start_date)
                    end_date_var.set(end_date)
                    
                    # Convertir pour affichage
                    display_start = convert_date_format(start_date, "yyyy-mm-dd", "dd-mm-yyyy")
                    display_end = convert_date_format(end_date, "yyyy-mm-dd", "dd-mm-yyyy")
                    
                    # Mettre √† jour les champs d'affichage
                    start_entry.config(state="normal")
                    start_entry.delete(0, tk.END)
                    start_entry.insert(0, display_start)
                    start_entry.config(state="readonly")
                    
                    end_entry.config(state="normal")
                    end_entry.delete(0, tk.END)
                    end_entry.insert(0, display_end)
                    end_entry.config(state="readonly")
                    
                    date_picker.destroy()
                elif len(selected_dates) == 1:  # Une seule date s√©lectionn√©e
                    # Stocker la date originale (YYYY-MM-DD) dans la variable pour traitement
                    start_date_var.set(selected_date)
                    
                    # Convertir pour affichage
                    display_start = convert_date_format(selected_date, "yyyy-mm-dd", "dd-mm-yyyy")
                    
                    # Mettre √† jour le champ d'affichage
                    start_entry.config(state="normal")
                    start_entry.delete(0, tk.END)
                    start_entry.insert(0, display_start)
                    start_entry.config(state="readonly")

            def close_calendar():
                """Ferme le calendrier en ne retenant qu'une seule date si n√©cessaire."""
                if len(selected_dates) == 1:  # Si une seule date est s√©lectionn√©e
                    # Une seule date = m√™me d√©but et fin
                    start_date_var.set(selected_dates[0])
                    end_date_var.set(selected_dates[0])
                    
                    # Convertir pour affichage
                    display_date = convert_date_format(selected_dates[0], "yyyy-mm-dd", "dd-mm-yyyy")
                    
                    # Mettre √† jour les champs d'affichage
                    start_entry.config(state="normal")
                    start_entry.delete(0, tk.END)
                    start_entry.insert(0, display_date)
                    start_entry.config(state="readonly")
                    
                    end_entry.config(state="normal")
                    end_entry.delete(0, tk.END)
                    end_entry.insert(0, display_date)
                    end_entry.config(state="readonly")
                    
                date_picker.destroy()

            # Cr√©e la fen√™tre de calendrier
            date_picker = tk.Toplevel(parent_frame.winfo_toplevel())
            date_picker.title("S√©lectionner les dates")
            date_picker.geometry("400x400")  # Fen√™tre plus grande
            date_picker.configure(bg="#f0f4f7")  # Fond assorti

            message_var = tk.StringVar()
            message_var.set("S√©lectionnez la date de d√©but.")
            
            # Titre principal stylis√©
            tk.Label(date_picker, 
                    text="S√©lection des dates", 
                    font=("Arial", 14, "bold"),
                    bg="#4a90e2", 
                    fg="white",
                    padx=10,
                    pady=5).pack(fill="x", pady=(0, 10))
                    
            # Message d'instruction
            instruction_label = tk.Label(date_picker, 
                                    textvariable=message_var, 
                                    font=("Arial", 11),
                                    bg="#f0f4f7",
                                    pady=5)
            instruction_label.pack(pady=5)

            # Calendrier am√©lior√©
            calendar = Calendar(
                date_picker,
                date_pattern="dd-mm-yyyy",  # Format jj-mm-aaaa
                background="#f0f4f7",       # Fond assorti
                foreground="#333333",       # Texte fonc√©
                selectbackground="#4a90e2", # Bleu pour s√©lection
                selectforeground="white",   # Texte blanc sur s√©lection
                normalbackground="white",   # Fond blanc jours normaux
                weekendbackground="#f5f5f5",# Gris clair weekends
                weekendforeground="#e74c3c",# Rouge pour weekends
                othermonthforeground="#aaaaaa", # Gris pour jours autres mois
                font=("Arial", 10),        # Police lisible
                bordercolor="#4a90e2",     # Bordure bleue
                headersbackground="#4a90e2", # En-t√™te bleu
                headersforeground="white",   # Texte blanc pour en-t√™te
            )
            calendar.pack(pady=10, padx=20, fill="both", expand=True)

            # Cadre pour les boutons avec style
            button_frame = tk.Frame(date_picker, bg="#f0f4f7")
            button_frame.pack(pady=10, fill="x")

            # Boutons stylis√©s
            select_button = tk.Button(
                button_frame, 
                text="Valider", 
                command=on_date_select,
                bg="#4a90e2", 
                fg="white",
                font=("Arial", 10, "bold"),
                width=10,
                padx=5,
                pady=3,
                relief="flat",
                cursor="hand2"
            )
            select_button.pack(side="left", padx=20)

            close_button = tk.Button(
                button_frame, 
                text="Fermer", 
                command=close_calendar,
                bg="#f44336", 
                fg="white",
                font=("Arial", 10, "bold"),
                width=10,
                padx=5,
                pady=3,
                relief="flat",
                cursor="hand2"
            )
            close_button.pack(side="right", padx=20)

            # Centrer la fen√™tre
            date_picker.update_idletasks()
            width = date_picker.winfo_width()
            height = date_picker.winfo_height()
            x = (date_picker.winfo_screenwidth() // 2) - (width // 2)
            y = (date_picker.winfo_screenheight() // 2) - (height // 2)
            date_picker.geometry(f'{width}x{height}+{x}+{y}')

            # D√©finir cette fen√™tre comme modale
            date_picker.transient(parent_frame.winfo_toplevel())
            date_picker.grab_set()
            date_picker.focus_set()
        
        # Bouton pour s√©lectionner les dates
        tk.Label(form_frame, text="Dates de d√©but et de fin :", bg="#f0f4f7").grid(row=1, column=0, sticky="w", pady=5)
        tk.Button(form_frame, text="üìÖ S√©lectionner les dates", command=select_dates).grid(row=1, column=1, sticky="w", padx=5, pady=5)
        
        start_date_var = StringVar()
        end_date_var = StringVar()
        
        # Date de d√©but
        tk.Label(form_frame, text="Date de d√©but :", bg="#f0f4f7").grid(row=2, column=0, sticky="w", pady=5)
        start_entry = Entry(form_frame, textvariable=start_date_var, state="readonly")
        start_entry.grid(row=2, column=1, sticky="w", padx=5, pady=5)
        
        # Date de fin
        tk.Label(form_frame, text="Date de fin :", bg="#f0f4f7").grid(row=3, column=0, sticky="w", pady=5)
        end_entry = Entry(form_frame, textvariable=end_date_var, state="readonly")
        end_entry.grid(row=3, column=1, sticky="w", padx=5, pady=5)
        
        # Date de signature
        tk.Label(form_frame, text="Date de signature :", bg="#f0f4f7").grid(row=4, column=0, sticky="w", pady=5)
        sign_date_var = StringVar(value=datetime.today().strftime("%Y-%m-%d"))
        Entry(form_frame, textvariable=sign_date_var).grid(row=4, column=1, sticky="w", padx=5, pady=5)
        
        # Nombre d'heures par jour
        tk.Label(form_frame, text="Nombre d'heures par jour :", bg="#f0f4f7").grid(row=5, column=0, sticky="w", pady=5)
        nb_hours_var = StringVar(value="9")
        Entry(form_frame, textvariable=nb_hours_var).grid(row=5, column=1, sticky="w", padx=5, pady=5)
        
        # Fonction pour enregistrer le contrat
        def save_contract_iade():
            """G√©n√®re un fichier Excel et un contrat IADE, puis affiche les options post-contrat."""
            # R√©cup√©ration des valeurs depuis l'interface
            replacing_name = replacing_var.get()
            start_date = ensure_correct_date_format(start_date_var.get())
            end_date = ensure_correct_date_format(end_date_var.get())
            sign_date = ensure_correct_date_format(sign_date_var.get())
            nb_hours = nb_hours_var.get()

            # V√©rification que tous les champs sont bien remplis
            if not replacing_name or not start_date or not end_date or not sign_date or not nb_hours:
                print("‚ùå Erreur : Tous les champs doivent √™tre remplis.")
                return

            try:
                # R√©cup√©rer les donn√©es de l'IADE depuis la base
                replacing_data = iade_data[iade_data["NOMR"] == replacing_name].iloc[0]
                replacing_email = replacing_data["EMAIL"]
                
                # R√©cup√©ration du pr√©nom et nom complet
                replacing_full_name = f"{replacing_data['PRENOMR']} {replacing_data['NOMR']}".strip()

            except IndexError:
                print(f"‚ùå Erreur : Impossible de trouver l'IADE '{replacing_name}' dans la base.")
                return

            # Correction de l'email pour √©viter 'nan'
            if pd.isna(replacing_email) or replacing_email in ["", "nan"]:
                replacing_email = "email_inconnu@exemple.com"

            # D√©finir les colonnes du fichier Excel temporaire
            columns = [
                "SEXE", "NOMR", "PRENOMR", "DDNR", "ER", "ILR", "SALARIER",
                "LIEUNR", "DPTN", "ADRESSER", "NOSSR", "NATR", "EMAIL",
                "DATEDEBUT", "DATEFIN", "DATESIGN", "NBHEURES"
            ]

            # R√©cup√©rer les informations de l'IADE s√©lectionn√©
            row_data = {
                "SEXE": replacing_data.get("SEXE", "Monsieur"),
                "NOMR": replacing_data["NOMR"],
                "PRENOMR": replacing_data["PRENOMR"],
                "DDNR": replacing_data.get("DDNR", ""),
                "ER": replacing_data.get("ER", ""),
                "ILR": replacing_data.get("ILR", "il"),
                "SALARIER": replacing_data.get("SALARIER", "au salari√©"),
                "LIEUNR": replacing_data.get("LIEUNR", ""),
                "DPTN": replacing_data.get("DPTN", ""),
                "ADRESSER": replacing_data.get("ADRESSER", ""),
                "NOSSR": replacing_data.get("NOSSR", ""),
                "NATR": replacing_data.get("NATR", ""),
                "EMAIL": replacing_email,
                "DATEDEBUT": start_date,
                "DATEFIN": end_date,
                "DATESIGN": sign_date,
                "NBHEURES": nb_hours
            }

            # Cr√©er un DataFrame avec les donn√©es
            contrat_iade = pd.DataFrame([row_data])

            # D√©finir le chemin du fichier temporaire
            excel_temp_path = os.path.join(os.path.dirname(file_paths["excel_iade"]), "temp_contrat_iade.xlsx")

            # Sauvegarder dans un fichier Excel temporaire
            save_to_new_excel(contrat_iade, excel_temp_path, "CONTRAT")

            print(f"‚úÖ Donn√©es du contrat IADE enregistr√©es dans {excel_temp_path}")

            # Effectuer le publipostage et g√©n√©rer le PDF
            pdf_path = perform_mail_merge(
                file_paths["word_iade"],  # Mod√®le Word pour IADE
                None,  # IADE n'a pas de remplac√©
                replacing_full_name,
                start_date,
                os.path.expanduser(file_paths["pdf_iade"]),
                contract_type="IADE"
            )

            if not pdf_path:
                print("‚ùå Erreur : Le fichier PDF n'a pas pu √™tre g√©n√©r√©.")
                return
                
            print(f"‚úÖ Contrat IADE enregistr√© sous : {pdf_path}")
            
            # D√©sactiver les √©l√©ments du formulaire
            for widget in form_frame.winfo_children():
                if isinstance(widget, (tk.Entry, tk.Button, tk.OptionMenu)):
                    widget.configure(state="disabled")
                    
            # Vider le conteneur d'actions
            for widget in actions_container.winfo_children():
                widget.destroy()
                
            # Afficher les actions post-contrat
            show_post_contract_actions(
                actions_container, 
                pdf_path, 
                None,  # Pas de remplac√© pour IADE
                replacing_full_name, 
                None,  # Pas d'email de remplac√©
                replacing_email, 
                start_date, 
                end_date, 
                "IADE"
            )
        
        # Bouton de cr√©ation et annulation
        tk.Button(form_frame, text="Cr√©er le contrat", command=save_contract_iade, 
                font=("Arial", 12, "bold"), bg="#007ACC", fg="black").grid(row=6, column=0, pady=10, padx=5, sticky="w")
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        tk.Label(parent_frame, text=f"Erreur lors de la cr√©ation de l'interface : {str(e)}", 
                 font=("Arial", 12), fg="red").pack(pady=20)

# Fonctions de gestion appel√©es par main.py
def manage_mar_titulaires():
    """
    Ouvre l'interface de gestion des MAR titulaires.
    """
    messagebox.showinfo("Fonctionnalit√© √† venir", "La gestion des MAR titulaires sera disponible prochainement.")

def manage_mar_remplacants():
    """
    Ouvre l'interface de gestion des MAR rempla√ßants.
    """
    messagebox.showinfo("Fonctionnalit√© √† venir", "La gestion des MAR rempla√ßants sera disponible prochainement.")

def manage_iade_remplacants():
    """
    Ouvre l'interface de gestion des IADE rempla√ßants.
    """
    messagebox.showinfo("Fonctionnalit√© √† venir", "La gestion des IADE rempla√ßants sera disponible prochainement.")

def manage_salaries():
    """
    Ouvre l'interface de gestion des salari√©s.
    """
    messagebox.showinfo("Fonctionnalit√© √† venir", "La gestion des salari√©s sera disponible prochainement.")
